<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API for users · MicroMagnetic.jl</title><meta name="title" content="API for users · MicroMagnetic.jl"/><meta property="og:title" content="API for users · MicroMagnetic.jl"/><meta property="twitter:title" content="API for users · MicroMagnetic.jl"/><meta name="description" content="Documentation for MicroMagnetic.jl."/><meta property="og:description" content="Documentation for MicroMagnetic.jl."/><meta property="twitter:description" content="Documentation for MicroMagnetic.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><script src="../assets/init.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MicroMagnetic.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../basics/">Basics</a></li><li><a class="tocitem" href="../units/">Units</a></li><li><span class="tocitem">Tutorials</span><ul><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Micromagnetics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../tutorials/micromagnetics/nanobar/">Nanobar</a></li><li><a class="tocitem" href="../tutorials/micromagnetics/vortex/">Magnetic vortex</a></li><li><a class="tocitem" href="../tutorials/micromagnetics/std4_sim_with/">Standard Problem 4 (sim_with)</a></li><li><a class="tocitem" href="../tutorials/micromagnetics/std4/">Standard Problem 4</a></li><li><a class="tocitem" href="../tutorials/micromagnetics/std5_sim_with/">Standard Problem 5 (sim_with)</a></li><li><a class="tocitem" href="../tutorials/micromagnetics/std5/">Standard Problem 5</a></li><li><a class="tocitem" href="../tutorials/micromagnetics/skyrmion_stt/">Skyrmion dynamics under spin transfer torques</a></li><li><a class="tocitem" href="../tutorials/micromagnetics/stoner_wohlfarth/">Stoner–Wohlfarth model</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Atomistic</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../tutorials/atomistic/skyrmion/">Magnetic skyrmion</a></li><li><a class="tocitem" href="../tutorials/atomistic/skyrmion_lattice/">Skyrmion lattice</a></li><li><a class="tocitem" href="../tutorials/atomistic/skyrmion_afm/">Antiferromagnetic skyrmion</a></li><li><a class="tocitem" href="../tutorials/atomistic/sllg/">Stochastic LLG</a></li><li><a class="tocitem" href="../tutorials/atomistic/phase_diagram/">Phase diagram</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-3" type="checkbox"/><label class="tocitem" for="menuitem-4-3"><span class="docs-label">Monte carlo</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../tutorials/monte_carlo/M_T_curve/">M-T curve using Monte Carlo</a></li><li><a class="tocitem" href="../tutorials/monte_carlo/skyrmion/">Skyrmion Phase using Monte Carlo</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Neb</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../tutorials/neb/neb_skx/">Skyrmion collapse using NEB</a></li></ul></li></ul></li><li><a class="tocitem" href="../equations/">Equations</a></li><li class="is-active"><a class="tocitem" href>API for users</a><ul class="internal"><li><a class="tocitem" href="#Meshes-–-MicroMagnetic"><span>Meshes – MicroMagnetic</span></a></li><li><a class="tocitem" href="#Meshes-–-Atomistic"><span>Meshes – Atomistic</span></a></li><li><a class="tocitem" href="#Shapes"><span>Shapes</span></a></li><li><a class="tocitem" href="#Interfaces"><span>Interfaces</span></a></li><li><a class="tocitem" href="#Interfaces-–-MicroMagnetic"><span>Interfaces – MicroMagnetic</span></a></li><li><a class="tocitem" href="#Interfaces-–-Atomistic"><span>Interfaces – Atomistic</span></a></li><li><a class="tocitem" href="#DataSaving"><span>DataSaving</span></a></li><li><a class="tocitem" href="#Tools"><span>Tools</span></a></li><li><a class="tocitem" href="#Others"><span>Others</span></a></li></ul></li><li><a class="tocitem" href="../api_dev/">API for developers</a></li><li><a class="tocitem" href="../contrib/">Contributing</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API for users</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API for users</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/MagneticSimulation/MicroMagnetic.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/master/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-for-users"><a class="docs-heading-anchor" href="#API-for-users">API for users</a><a id="API-for-users-1"></a><a class="docs-heading-anchor-permalink" href="#API-for-users" title="Permalink"></a></h1><h2 id="Meshes-–-MicroMagnetic"><a class="docs-heading-anchor" href="#Meshes-–-MicroMagnetic">Meshes – MicroMagnetic</a><a id="Meshes-–-MicroMagnetic-1"></a><a class="docs-heading-anchor-permalink" href="#Meshes-–-MicroMagnetic" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.FDMesh-Tuple{}" href="#MicroMagnetic.FDMesh-Tuple{}"><code>MicroMagnetic.FDMesh</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FDMesh(; dx=1e-9, dy=1e-9, dz=1e-9, nx=1, ny=1, nz=1, pbc=&quot;open&quot;)</code></pre><p>Create a finite difference mesh (<code>FDMesh</code>) for simulations. This method is designed for the <a href="../equations/#Micromagnetic-model">Micromagnetic model</a>.</p><p>This constructor initializes a finite difference mesh with the specified parameters. The <code>pbc</code> (periodic boundary conditions) parameter can be any combination of the characters <code>&quot;x&quot;</code>, <code>&quot;y&quot;</code>, and <code>&quot;z&quot;</code>, which determines whether the mesh wraps around the corresponding axis.</p><p><strong>Parameters:</strong></p><ul><li><code>dx::Float64</code>: Grid spacing in the x-direction (default: <code>1e-9</code>).</li><li><code>dy::Float64</code>: Grid spacing in the y-direction (default: <code>1e-9</code>).</li><li><code>dz::Float64</code>: Grid spacing in the z-direction (default: <code>1e-9</code>).</li><li><code>nx::Int</code>: Number of grid points in the x-direction (default: <code>1</code>).</li><li><code>ny::Int</code>: Number of grid points in the y-direction (default: <code>1</code>).</li><li><code>nz::Int</code>: Number of grid points in the z-direction (default: <code>1</code>).</li><li><code>pbc::String</code>: Periodic boundary conditions, which could be any combination of <code>&quot;x&quot;</code>, <code>&quot;y&quot;</code>, and <code>&quot;z&quot;</code> (default: <code>&quot;open&quot;</code>).</li></ul><p><strong>Examples:</strong></p><pre><code class="language-julia hljs">mesh = FDMesh(dx=1e-8, dy=1e-8, dz=1e-8, nx=10, ny=10, nz=10, pbc=&quot;xyz&quot;)</code></pre><p>This creates a FDMesh with 10 grid points in each direction and periodic boundary conditions in all three axes. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/micro/mesh.jl#L41-L62">source</a></section></article><h2 id="Meshes-–-Atomistic"><a class="docs-heading-anchor" href="#Meshes-–-Atomistic">Meshes – Atomistic</a><a id="Meshes-–-Atomistic-1"></a><a class="docs-heading-anchor-permalink" href="#Meshes-–-Atomistic" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.CubicMesh-Tuple{}" href="#MicroMagnetic.CubicMesh-Tuple{}"><code>MicroMagnetic.CubicMesh</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CubicMesh(;dx=1e-9, dy=1e-9, dz=1e-9, nx=1, ny=1, nz=1, pbc=&quot;open&quot;)</code></pre><p>Create a simple cubic mesh, in which each cell is only connected to six nearest neighbors  and forming a simple cube structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/atomistic/mesh.jl#L156-L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.TriangularMesh-Tuple{}" href="#MicroMagnetic.TriangularMesh-Tuple{}"><code>MicroMagnetic.TriangularMesh</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TriangularMesh(; dx=1e-9, nx=1, ny=1, nz=1, pbc=&quot;open&quot;)</code></pre><p>Create a triangular mesh. The index of the nearest neighbours and the next-nearest  neighbours are given as follows:</p><table><tr><th style="text-align: center">nearest index</th><th style="text-align: center">location</th><th style="text-align: center">next-nearest index</th><th style="text-align: center">location</th></tr><tr><td style="text-align: center">1</td><td style="text-align: center">right</td><td style="text-align: center">1</td><td style="text-align: center">top-right</td></tr><tr><td style="text-align: center">2</td><td style="text-align: center">top-right</td><td style="text-align: center">2</td><td style="text-align: center">top</td></tr><tr><td style="text-align: center">3</td><td style="text-align: center">top-left</td><td style="text-align: center">3</td><td style="text-align: center">top-left</td></tr><tr><td style="text-align: center">4</td><td style="text-align: center">left</td><td style="text-align: center">4</td><td style="text-align: center">bottom-left</td></tr><tr><td style="text-align: center">5</td><td style="text-align: center">bottom-left</td><td style="text-align: center">5</td><td style="text-align: center">bottom</td></tr><tr><td style="text-align: center">6</td><td style="text-align: center">bottom-right</td><td style="text-align: center">6</td><td style="text-align: center">bottom-right</td></tr><tr><td style="text-align: center">7</td><td style="text-align: center">above</td><td style="text-align: center"></td><td style="text-align: center"></td></tr><tr><td style="text-align: center">8</td><td style="text-align: center">below</td><td style="text-align: center"></td><td style="text-align: center"></td></tr></table></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/atomistic/mesh.jl#L73-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.CylindricalTubeMesh-Tuple{}" href="#MicroMagnetic.CylindricalTubeMesh-Tuple{}"><code>MicroMagnetic.CylindricalTubeMesh</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CylindricalTubeMesh(;dz=1e-9, R=20e-9, nz=1, nr=10, pbc=&quot;open&quot;)</code></pre><p>Create a cylindrical tube mesh along the +z direction. </p><p>The spins are located on the cylindrical tube uniformly, and are indexed as follows:</p><pre><code class="language-julia hljs">  id = index(i, 1, k, nr, 1, nz)</code></pre><p>which means that the spins are labelled in a ring firstly, then <code>nz</code> is the number of rings.   The coordinates of the spins at each ring are given as <code>(R cos(2*pi*(i-1)/nr), R sin(2*pi*(nr-1)/nr))</code>.</p><p>The nearest neighbours are indexed as follows:</p><p>|  1      2        3       4            |left   right    bottom   top |</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/atomistic/mesh.jl#L343-L359">source</a></section></article><h2 id="Shapes"><a class="docs-heading-anchor" href="#Shapes">Shapes</a><a id="Shapes-1"></a><a class="docs-heading-anchor-permalink" href="#Shapes" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.Cylinder" href="#MicroMagnetic.Cylinder"><code>MicroMagnetic.Cylinder</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Cylinder(;center = (0.0, 0.0, 0.0), radius = 1.0, height= Inf, normal = (0.0, 0.0, 1.0))</code></pre><p>Create a Cylinder shape. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/csg.jl#L38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.Box" href="#MicroMagnetic.Box"><code>MicroMagnetic.Box</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Box(;center::Tuple=(0.0, 0.0, 0.0), sides::Tuple=(1.0,1.0,1.0), theta=0.0)</code></pre><p>Create a Box shape.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/csg.jl#L56-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.Torus" href="#MicroMagnetic.Torus"><code>MicroMagnetic.Torus</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Torus(; center::Tuple=(0.0, 0.0, 0.0), R=1.0, r=0.2)</code></pre><p>Create a Torus shape.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/csg.jl#L70-L74">source</a></section></article><h2 id="Interfaces"><a class="docs-heading-anchor" href="#Interfaces">Interfaces</a><a id="Interfaces-1"></a><a class="docs-heading-anchor-permalink" href="#Interfaces" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.sim_with" href="#MicroMagnetic.sim_with"><code>MicroMagnetic.sim_with</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sim_with(args::Union{NamedTuple, Dict})</code></pre><p><a href="../basics/#High-Level-Interface">High-Level Interface</a> for starting a typical micromagnetic simulation. All parameters are set using <code>args</code>, which can be either a <code>NamedTuple</code> or a <code>Dict</code>.</p><p><strong>Keywords</strong></p><ul><li><code>mesh</code>: A mesh must be provided to start the simulation. The mesh could be <a href="#MicroMagnetic.FDMesh-Tuple{}"><code>FDMesh</code></a>, <a href="#MicroMagnetic.CubicMesh-Tuple{}"><code>CubicMesh</code></a>, or <a href="#MicroMagnetic.TriangularMesh-Tuple{}"><code>TriangularMesh</code></a>.</li><li><code>name</code>: The name of the simulation, provided as a string.</li><li><code>task</code>: The type of simulation task, which can be <code>&quot;Relax&quot;</code> or <code>&quot;Dynamics&quot;</code>. The default is &quot;Relax&quot;.</li><li><code>driver</code>: The name of the driver, which should be &quot;SD&quot;, &quot;LLG&quot;, or &quot;LLG_STT&quot;. The default is &quot;SD&quot;.</li><li><code>alpha</code>: The Gilbert damping parameter in the LLG equation, provided as a number.</li><li><code>beta</code>: The nonadiabatic strength in the LLG equation with spin-transfer torques (Zhang-Li model), provided as a number.</li><li><code>gamma</code>: The gyromagnetic ratio, with a default value of 2.21e5.</li><li><code>ux</code>, <code>uy</code>, <code>uz</code>: The components of the spin-transfer torque strength.</li><li><code>ufun</code>: A time-dependent function for <code>u</code>.</li><li><code>Ms</code>: The saturation magnetization, which should be a <a href="../api_dev/#MicroMagnetic.NumberOrArrayOrFunction"><code>NumberOrArrayOrFunction</code></a>. The default is <code>Ms=8e5</code>.</li><li><code>mu_s</code>: The magnetic moment, which should be a <a href="../api_dev/#MicroMagnetic.NumberOrArrayOrFunction"><code>NumberOrArrayOrFunction</code></a>. The default is <code>mu_s=2*mu_B</code>.</li><li><code>A</code> or <code>J</code>: The exchange constant, which should be a <a href="../api_dev/#MicroMagnetic.NumberOrArrayOrFunction"><code>NumberOrArrayOrFunction</code></a>.</li><li><code>D</code>: The Dzyaloshinskii-Moriya interaction (DMI) constant, which should be a <a href="../api_dev/#MicroMagnetic.NumberOrArrayOrFunction"><code>NumberOrArrayOrFunction</code></a>.</li><li><code>dmi_type</code>: The type of DMI, either &quot;bulk&quot; or &quot;interfacial&quot;.</li><li><code>Ku</code>: The anisotropy constant, which should be a <a href="../api_dev/#MicroMagnetic.NumberOrArrayOrFunction"><code>NumberOrArrayOrFunction</code></a>.</li><li><code>axis</code>: The anisotropy axis, provided as a tuple, e.g., <code>(0, 0, 1)</code>.</li><li><code>Kc</code>: the cubic anisotropy constant, should be <a href="../api_dev/#MicroMagnetic.NumberOrArrayOrFunction"><code>NumberOrArrayOrFunction</code></a>.</li><li><code>axis1</code>: the cubic anisotropy axis1, should be a tuple, such as (1,0,0)</li><li><code>axis2</code>: the cubic anisotropy axis2, should be a tuple, such as (0,1,0)</li><li><code>demag</code>: Whether to include demagnetization. This should be a boolean (<code>true</code> or <code>false</code>). The default is <code>demag=false</code>.</li><li><code>H</code>: The external magnetic field, which should be a tuple or function, i.e., <a href="../api_dev/#MicroMagnetic.TupleOrArrayOrFunction"><code>TupleOrArrayOrFunction</code></a>.</li><li><code>m0</code>: The initial magnetization, which should be a tuple or function, i.e., <a href="../api_dev/#MicroMagnetic.TupleOrArrayOrFunction"><code>TupleOrArrayOrFunction</code></a>.</li><li><code>T</code>: The temperature, which should be a <a href="../api_dev/#MicroMagnetic.NumberOrArrayOrFunction"><code>NumberOrArrayOrFunction</code></a>.</li><li><code>shape</code>: The shape defines the geometry of the sample, where parameters are configured.</li><li><code>steps</code>: The total number of simulation steps for the <code>Dynamics</code> task.</li><li><code>dt</code>: The time interval of each step, so the total simulation time is <code>steps * dt</code> for the <code>Dynamics</code> task.</li><li><code>max_steps::Int</code>: Maximum number of steps to run the simulation for the <code>Relax</code> task. Default is <code>10000</code>.</li><li><code>saver_item</code>: A <code>SaverItem</code> instance or a list of <code>SaverItem</code> instances. These are custom data-saving utilities that can be used to store additional quantities during the simulation (e.g., guiding centers or other derived values). If <code>nothing</code>, no additional data is saved beyond the default.</li><li><code>call_back</code>: A user-defined function or <code>nothing</code>. If provided, this function will be called at every step, allowing for real-time inspection or manipulation of the simulation state.</li><li><code>stopping_dmdt::Float64</code>: Primary stopping condition for both <code>LLG</code> and <code>SD</code> drivers. For standard micromagnetic simulations, typical values range from <code>0.01</code> to <code>1</code>. In <code>SD</code> driver mode, where time is not strictly defined, a factor of <code>γ</code> is applied to make it comparable to the <code>LLG</code> driver. For atomistic models using dimensionless units, set <code>using_time_factor</code> to <code>false</code> to disable this factor.</li><li><code>relax_data_interval::Int</code>: Interval for saving overall data such as energies and average magnetization during a <code>Relax</code> task. A negative value disables data saving (e.g., <code>relax_data_interval = -1</code> saves data only at the end of the relaxation).</li><li><code>dynamic_data_save::Bool</code>: Boolean flag to enable or disable saving overall data such as energies and average magnetization during the <code>Dynamics</code> task. Set to <code>true</code> to enable, or <code>false</code> to disable.</li><li><code>relax_m_interval::Int</code>: Interval for saving magnetization data during a <code>Relax</code> task. A negative value disables magnetization saving.</li><li><code>dynamic_m_interval::Int</code>: Interval for saving magnetization data during a <code>Dynamics</code> task. A negative value disables magnetization saving.</li><li><code>using_time_factor::Bool</code>: Boolean flag to apply a time factor in <code>SD</code> mode for comparison with <code>LLG</code> mode. Default is <code>true</code>.</li><li><code>save_vtk::Bool</code>: Boolean flag to save the magnetization to vtk files after finishing each task. Default is <code>false</code>.</li></ul><p><strong>Example</strong></p><p>See examples at <a href="../basics/#High-Level-Interface">High-Level Interface</a>.</p><p><strong>Notes</strong></p><ul><li><strong>Suffix Usage</strong>: Parameters like <code>H</code>, <code>Ms</code>, <code>Ku</code>, <code>A</code>, <code>D</code>, <code>task</code>, and <code>driver</code> can be defined as arrays using the <code>_s</code> or <code>_sweep</code> suffix. When using these suffixes, ensure that the corresponding array lengths match. This allows the simulation to iterate over different values for these parameters.</li><li><strong>Argument Types</strong>: The <code>args</code> parameter can be either a <code>NamedTuple</code> or a <code>Dict</code>, providing flexibility in how you organize and pass the simulation parameters.</li><li><strong>Driver Selection</strong>: The <code>driver</code> parameter (or <code>driver_s</code> for multiple drivers) specifies the simulation type. Options include <code>&quot;SD&quot;</code> for the steepest-descent method, <code>&quot;LLG&quot;</code> for the Landau-Lifshitz-Gilbert equation, and <code>&quot;LLG_STT&quot;</code> for simulations involving spin-transfer torques.</li><li><strong>Stopping Criterion</strong>: The <code>stopping_dmdt</code> parameter is critical for determining when to stop a simulation, particularly in relaxation tasks. It measures the rate of change in magnetization, with typical values ranging from <code>0.01</code> to <code>1</code>. For atomistic models, the <code>using_time_factor</code> flag can be set to <code>false</code> to disable time scaling.</li><li><strong>Data Saving</strong>: The <code>relax_m_interval</code> and <code>dynamic_m_interval</code> parameters control how frequently magnetization data is saved during <code>Relax</code> and <code>Dynamics</code> tasks, respectively. Use negative values to disable data saving for these tasks.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/sim.jl#L703-L759">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.set_backend" href="#MicroMagnetic.set_backend"><code>MicroMagnetic.set_backend</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_backend(backend=&quot;cuda&quot;)</code></pre><p>Set the backend of MicroMagnetic. This function allows you to specify the backend for MicroMagnetic simulations. </p><p>The available options and their corresponding hardware and backends are shown below:</p><table><tr><th style="text-align: left">Option</th><th style="text-align: left">Hardware</th><th style="text-align: left">Backend</th></tr><tr><td style="text-align: left">&quot;cpu&quot;</td><td style="text-align: left">CPU</td><td style="text-align: left"><code>KernelAbstractions.CPU()</code></td></tr><tr><td style="text-align: left">&quot;cuda&quot; or &quot;nvidia&quot;</td><td style="text-align: left">NVIDIA GPU</td><td style="text-align: left"><code>CUDA.CUDABackend()</code></td></tr><tr><td style="text-align: left">&quot;amd&quot; or &quot;roc&quot;</td><td style="text-align: left">AMD GPU</td><td style="text-align: left"><code>AMDGPU.ROCBackend()</code></td></tr><tr><td style="text-align: left">&quot;oneAPI&quot; or &quot;intel&quot;</td><td style="text-align: left">Intel GPU</td><td style="text-align: left"><code>oneAPI.oneAPIBackend()</code></td></tr><tr><td style="text-align: left">&quot;metal&quot; or &quot;apple&quot;</td><td style="text-align: left">Apple GPU</td><td style="text-align: left"><code>Metal.MetalBackend()</code></td></tr></table><p><strong>Examples</strong></p><p>To set the backend to use CUDA (NVIDIA GPU):</p><pre><code class="language-julia hljs">using MicroMagnetic
using CUDA</code></pre><p>To set the backend to use the CPU/CUDA:</p><pre><code class="nohighlight hljs">set_backend(&quot;cpu&quot;)
set_backend(&quot;cuda&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/MicroMagnetic.jl#L55-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.set_precision" href="#MicroMagnetic.set_precision"><code>MicroMagnetic.set_precision</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_precision(x::Type{&lt;:AbstractFloat}=Float64)</code></pre><p>Set the precision for MicroMagnetic simulations.</p><p>This function allows you to specify the precision of floating-point numbers to be used in MicroMagnetic simulations.  By default, it sets the precision to <code>Float64</code>. If single-precision computation is required, you can specify <code>Float32</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">set_precision(Float32)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/MicroMagnetic.jl#L16-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.set_verbose" href="#MicroMagnetic.set_verbose"><code>MicroMagnetic.set_verbose</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_verbose(verbose::Bool=false)</code></pre><p>Sets the global verbosity level for logging.</p><p><strong>Arguments</strong></p><ul><li><code>verbose::Bool</code>: If true, enables verbose logging; if false, disables it. Default is false.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">set_verbose(true)  # Enables verbose logging
set_verbose(false) # Disables verbose logging</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/MicroMagnetic.jl#L126-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.Sim" href="#MicroMagnetic.Sim"><code>MicroMagnetic.Sim</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Sim(mesh::Mesh; driver=&quot;LLG&quot;, name=&quot;dyn&quot;, integrator=&quot;DormandPrince&quot;)</code></pre><p>Create a simulation instance for given mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/sim.jl#L6-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.NEB" href="#MicroMagnetic.NEB"><code>MicroMagnetic.NEB</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NEB(sim::AbstractSim, init_images::TupleOrArray, frames_between_images::TupleOrArray; 
    name=&quot;NEB&quot;, spring_constant=1.0e5, driver=&quot;LLG&quot;, clib_image=-1)</code></pre><p>Create a NEB instance.</p><p><strong>Arguments</strong></p><ul><li><code>sim::AbstractSim</code>: Simulation instance that includes the interactions.</li><li><code>init_images::TupleOrArray</code>: Tuple or array of initial and final state images. Intermediate state images can also be included.</li><li><code>frames_between_images::TupleOrArray</code>: Tuple or array specifying the number of frames between each pair of images.</li><li><code>name::String=&quot;NEB&quot;</code>: Name for the NEB instance.</li><li><code>spring_constant::Float64=1.0e5</code>: Spring constant used in the NEB simulation.</li><li><code>driver::String=&quot;LLG&quot;</code>: Driver for the NEB simulation. Options are <code>&quot;SD&quot;</code> or <code>&quot;LLG&quot;</code>.</li><li><code>clib_image::Int=-1</code>: Optional parameter for specifying a particular image in the library (default is -1).</li></ul><p><strong>Returns</strong></p><p>A NEB instance configured with the provided parameters.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># define mesh and the corresponding parameters
mesh = FDMesh(nx=60, ny=60, nz=1, dx=2e-9, dy=2e-9, dz=2e-9, pbc=&quot;xy&quot;)
params = Dict(
    :Ms =&gt; 3.84e5,
    :A =&gt; 3.25e-12,
    :D =&gt; 5.83e-4,
    :H =&gt; (0, 0, 120 * mT)
)

# Define the initial and final state, stored in the init_images list.
# Any acceptable object, such as a function, a tuple, or an array, can be used.
# The init_images list can also contain the intermediate state if you have one.
init_images = [read_vtk(&quot;skx.vts&quot;), (0, 0, 1)]

# Define the interpolation array to specify the number of images used in the NEB simulation.
# The length of the interpolation array should be the length of init_images minus one.
# For example, if init_images = [read_vtk(&quot;skx.vts&quot;), read_vtk(&quot;skx2.vts&quot;), (0, 0, 1)], 
# the length of interpolation should be 2, i.e., something like interpolation = [5,5].
interpolation = [6]

# Use the create_sim method to create a Sim instance.
sim = create_sim(mesh; params...)

# Create the NEB instance and set the spring_constant. The driver can be &quot;SD&quot; or &quot;LLG&quot;.
neb = NEB(sim, init_images, interpolation; name=&quot;skx_fm&quot;, driver=&quot;SD&quot;)
# neb.spring_constant = 1e7

# Relax the entire system.
relax(neb; stopping_dmdt=0.1, save_vtk_every=1000, max_steps=5000)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/neb/neb.jl#L31-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.set_driver" href="#MicroMagnetic.set_driver"><code>MicroMagnetic.set_driver</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_driver(sim::AbstractSim; driver=&quot;LLG&quot;, integrator=&quot;DormandPrince&quot;, args...)</code></pre><p>Set the driver of the simulation, can be used to switch the driver.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/sim.jl#L459-L463">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.init_m0" href="#MicroMagnetic.init_m0"><code>MicroMagnetic.init_m0</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">init_m0(sim::MicroSim, m0::TupleOrArrayOrFunction; norm=true)</code></pre><p>Set the initial magnetization of the system. If <code>norm=false</code> the magnetization array will be not normalised. Examples:</p><pre><code class="language-julia hljs">   init_m0(sim, (1,1,1))</code></pre><p>or</p><pre><code class="language-julia hljs">   init_m0(sim, (1,1,1), norm=false)</code></pre><p>or</p><pre><code class="language-julia hljs">   function uniform_m0(i,j,k,dx,dy,dz)
       return (0,0,1)
   end
   init_m0(sim, uniform_m0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/sim.jl#L151-L171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.init_m0_random" href="#MicroMagnetic.init_m0_random"><code>MicroMagnetic.init_m0_random</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">init_m0_random(sim::MicroSim)</code></pre><p>Set the initial magnetization with random direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/init_m.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.init_m0_skyrmion" href="#MicroMagnetic.init_m0_skyrmion"><code>MicroMagnetic.init_m0_skyrmion</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">init_m0_skyrmion(sim::AbstractSim, center::Tuple, R::Float64; ratio=0.7, p=-1, c=1, type=&quot;B&quot;)</code></pre><p>Set the magnetization with skyrmions. Note that this function can be called mulitple times to add more skyrmons.</p><p>center :  the skyrmion center, should be a Tuple. For example, center = (50e-9,50e-9)</p><p>R : the skyrmion radius.</p><p>ratio : ratio=w/R where w is the width of domain wall. By default ratio = 0.7</p><p>p : polarity, +1 –&gt; core up; -1 –&gt; core down</p><p>c : chirality, +1 –&gt; lefthand,for positive D; -1 –&gt; righthand,for negative D</p><p>type : &quot;B&quot; or &quot;N&quot;, representing Bloch or Neel skyrmions.</p><p>For example:</p><pre><code class="language-julia hljs">    init_m0_skyrmion(sim, (50e-9,50e-9), 2e-8, ratio=0.5, p=-1, c=1, type=&quot;B&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/init_m.jl#L25-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.add_zeeman" href="#MicroMagnetic.add_zeeman"><code>MicroMagnetic.add_zeeman</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_zeeman(sim::AbstractSim, H0::TupleOrArrayOrFunction; name=&quot;zeeman&quot;)</code></pre><p>Add a static Zeeman energy to the simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/micro/add_field.jl#L5-L9">source</a></section><section><div><pre><code class="language-julia hljs">add_zeeman(sim::AbstractSim, H0::TupleOrArrayOrFunction, ft::Function; name=&quot;timezeeman&quot;)</code></pre><p>Add a time varying zeeman to system.</p><p>The input <code>ft</code> is a function of time <code>t</code> and its return value should be a tuple with length 3.</p><p>Example:</p><pre><code class="language-julia hljs">  function time_fun(t)
    w = 2*pi*2.0e9
    return (sin(w*t), cos(w*t), 0)
  end

  function spatial_H(i, j, k, dx, dy, dz)
    H = 1e3
    if i&lt;=2
        return (H, H, 0)
    end
    return (0, 0, 0)
  end

  add_zeeman(sim, spatial_H, time_fun)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/micro/add_field.jl#L73-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.add_anis" href="#MicroMagnetic.add_anis"><code>MicroMagnetic.add_anis</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_anis(sim::AbstractSim, Ku::NumberOrArrayOrFunction; axis=(0,0,1), name=&quot;anis&quot;)</code></pre><p>Add Anisotropy to the system, where the energy density is given by</p><p class="math-container">\[    E_\mathrm{anis} =  K_{u} (1 - \vec{m} \cdot \hat{u})^2\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/micro/add_field.jl#L325-L333">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.add_cubic_anis" href="#MicroMagnetic.add_cubic_anis"><code>MicroMagnetic.add_cubic_anis</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_cubic_anis(sim::AbstractSim, Kc::Float64; axis1=(1,0,0), axis2=(0,1,0), name=&quot;cubic&quot;)</code></pre><p>add a cubic anisotropy with default axis (1,0,0) , (0,1,0), and (0,0,1). The third axis is defined as axis3 = axis1 x axis2.</p><p class="math-container">\[  E_\mathrm{cubic} = -\int_{V} K_c (m_x^4 + m_y^4 + m_z^4) \, dV\]</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">    add_cubic_anis(sim, 1e3, (1, 1, 0), (1, -1, 0))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/micro/add_field.jl#L423-L436">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.add_hex_anis" href="#MicroMagnetic.add_hex_anis"><code>MicroMagnetic.add_hex_anis</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_hex_anis(sim::AbstractSim; K1=0, K2=0, K3=0, name=&quot;hex&quot;)</code></pre><p>Add hexagonal anisotropy to a simulation. The energy density of the anisotropy is defined as:</p><p class="math-container">\[E = K_1 \sin^2 \theta + K_2 \sin^4 \theta + K_3 \sin^6 \theta \cos 6\phi\]</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">add_hex_anis(sim, K1=1e3, K2=0, K3=1e2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/micro/add_field.jl#L471-L484">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.add_she_torque" href="#MicroMagnetic.add_she_torque"><code>MicroMagnetic.add_she_torque</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_she_torque(sim::AbstractSim, sigma_s::Tuple{Real,Real,Real}, sigma_sa::Tuple{Real,Real,Real}; a1=(1,0,0), a2=(0,1,0), beta=0, name=&quot;she&quot;)</code></pre><p>Add an effective field to represent the SHE torque given by </p><p class="math-container">\[\frac{\partial \mathbf{m}}{\partial t} = - \gamma \mathbf{m} \times \mathbf{H} + \alpha \mathbf{m} \times  \frac{\partial \mathbf{m}}{\partial t} 
- \mathbf{m} \times (\mathbf{m} \times \boldsymbol{\sigma}_{x y}^\mathrm{S H E}) -  \beta\mathbf{m} \times \boldsymbol{\sigma}_{x y}^\mathrm{S H E}\]</p><p>The equivalent effective field is</p><p class="math-container">\[\mathbf{H}_\mathrm{she} = (1/\gamma)(\beta \boldsymbol{\sigma}_{x y}^\mathrm{S H E} + \mathbf{m} \times \boldsymbol{\sigma}_{x y}^\mathrm{S H E})\]</p><p>where </p><p class="math-container">\[\boldsymbol{\sigma}_{x y}^\mathrm{S H E}=\widetilde{\boldsymbol{\sigma}}_\mathrm{S} \times \hat{\mathbf{a}}_2-\left({\mathbf{m}} \cdot\left(\hat{\mathbf{a}}_2 \times \hat{\mathbf{a}}_1\right)\right)^2\left(\widetilde{\boldsymbol{\sigma}}_\mathrm{SA} \times \hat{\mathbf{a}}_2\right)\]</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">    add_she_torque(sim, (0.1, 0.2, 0.3), (0.3, 0.4, 0.5), beta=0.1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/micro/add_field.jl#L642-L666">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.add_thermal_noise" href="#MicroMagnetic.add_thermal_noise"><code>MicroMagnetic.add_thermal_noise</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_thermal_noise(sim::AbstractSim, Temp::NumberOrArrayOrFunction; name=&quot;thermal&quot;, scaling=t -&gt; 1.0, k_B=k_B)</code></pre><p>Adds thermal noise fields to the simulation. For micromagnetic model, the thermal noise is defined as</p><p class="math-container">\[\mathbf{b}^u = \eta \sqrt \frac{2 \alpha k_B T}{\mu_0 M_s \gamma \Delta V dt}\]</p><p>and <span>$\eta$</span> is a random number follows the normal distribution where <span>$\gamma=2.211\times 10^5$</span> m/(A·s) is the gyromagnetic ratio.</p><p>For the atomistic model, the thermal noise is defined as</p><p class="math-container">\[\mathbf{b}^u = \eta \sqrt \frac{2 \alpha k_B T}{\gamma \mu_s dt}.\]</p><p>where <span>$\eta$</span> is a random number follows the normal distribution and <span>$\gamma=1.76\times 10^{11}$</span> rad/(T·s). </p><p><strong>Arguments</strong></p><ul><li><code>sim::AbstractSim</code>: The simulation object.</li><li><code>Temp::NumberOrArrayOrFunction</code>: Temperature value (can be a constant, array, or function).</li><li><code>name::String</code>: Name for the noise field (default: <code>&quot;thermal&quot;</code>).</li><li><code>scaling::Function</code>: A function to scale the noise over time (default: <code>t -&gt; 1.0</code>).</li><li><code>k_B::Float64</code>: Boltzmann constant (default: <code>k_B</code>).</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Add thermal noise with a constant temperature of 100 K and a scaling function
add_thermal_noise(sim, 100.0, scaling = t -&gt; exp(-t/1e-9))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/micro/add_field.jl#L505-L534">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.update_zeeman" href="#MicroMagnetic.update_zeeman"><code>MicroMagnetic.update_zeeman</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_zeeman(sim::AbstractSim, H0::TupleOrArrayOrFunction; name=&quot;zeeman&quot;)</code></pre><p>Set the Zeeman field to H0 where H0 is TupleOrArrayOrFunction according to its name. For example,</p><pre><code class="language-julia hljs">   add_zeeman(sim, (0,0,0), name=&quot;my_H&quot;)  #create a zeeman energy with field (0,0,0) A/m
   update_zeeman(sim, (0,0,1e5), name=&quot;my_H&quot;)  #change the field to (0,0,1e5) A/m</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/micro/add_field.jl#L45-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.update_anis" href="#MicroMagnetic.update_anis"><code>MicroMagnetic.update_anis</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_anis(sim::MicroSim, Ku::NumberOrArrayOrFunction; name = &quot;anis&quot;)</code></pre><p>update anisotropy constant Ku according to its name.</p><p>Example:</p><pre><code class="language-julia hljs">    mesh = FDMesh(nx=200, ny=200, nz=12, dx=5e-9, dy=5e-9, dz=5e-9)
    sim = Sim(mesh)
    add_anis(sim, 3e4, axis = (0,0,1), name=&quot;K1&quot;)
    add_anis(sim, 1e5, axis = (1,0,0), name=&quot;K2&quot;)
    update_anis(sim, 5e4, name=&quot;K2&quot;)  #update anisotropy K2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/micro/add_field.jl#L396-L409">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.create_sim" href="#MicroMagnetic.create_sim"><code>MicroMagnetic.create_sim</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_sim(mesh; args...)</code></pre><p>Create a micromagnetic simulation instance with given arguments. </p><ul><li><code>mesh</code>: a mesh has to be provided to start the simulation. The mesh could be <a href="#MicroMagnetic.FDMesh-Tuple{}"><code>FDMesh</code></a>, <a href="#MicroMagnetic.CubicMesh-Tuple{}"><code>CubicMesh</code></a>, or <a href="#MicroMagnetic.TriangularMesh-Tuple{}"><code>TriangularMesh</code></a>.</li></ul><p><strong>Arguments</strong></p><ul><li><code>name</code> : the simulation name, should be a string.</li><li><code>driver</code> : the driver name, should be a string. By default, the driver is &quot;SD&quot;.</li><li><code>alpha</code> : the Gilbert damping in the LLG equation, should be a number.</li><li><code>beta</code> : the nonadiabatic strength in the LLG equation with spin transfer torques (zhang-li model), should be a number.</li><li><code>gamma</code> : the gyromagnetic ratio, default value = 2.21e5.</li><li><code>ux</code>, <code>uy</code> or <code>uz</code>: the strengths of the spin transfer torque.</li><li><code>ufun</code> : the time-dependent function for <code>u</code>. </li><li><code>Ms</code>: the saturation magnetization, should be <a href="../api_dev/#MicroMagnetic.NumberOrArrayOrFunction"><code>NumberOrArrayOrFunction</code></a>. By default, Ms=8e5</li><li><code>mu_s</code>: the magnetic moment, should be <a href="../api_dev/#MicroMagnetic.NumberOrArrayOrFunction"><code>NumberOrArrayOrFunction</code></a>. By default, mu<em>s=2*mu</em>B</li><li><code>A</code> or <code>J</code>: the exchange constant, should be <a href="../api_dev/#MicroMagnetic.NumberOrArrayOrFunction"><code>NumberOrArrayOrFunction</code></a>.</li><li><code>D</code> : the DMI constant, should be <a href="../api_dev/#MicroMagnetic.NumberOrArrayOrFunction"><code>NumberOrArrayOrFunction</code></a>.</li><li><code>dmi_type</code> : the type of DMI, could be &quot;bulk&quot;, &quot;interfacial&quot; or &quot;D2d&quot;.</li><li><code>Ku</code>: the anisotropy constant, should be <a href="../api_dev/#MicroMagnetic.NumberOrArrayOrFunction"><code>NumberOrArrayOrFunction</code></a>.</li><li><code>axis</code>: the anisotropy axis, should be a tuple, such as (0,0, 1)</li><li><code>Kc</code>: the cubic anisotropy constant, should be <a href="../api_dev/#MicroMagnetic.NumberOrArrayOrFunction"><code>NumberOrArrayOrFunction</code></a>.</li><li><code>axis1</code>: the cubic anisotropy axis1, should be a tuple, such as (1,0,0)</li><li><code>axis2</code>: the cubic anisotropy axis2, should be a tuple, such as (0,1,0)</li><li><code>demag</code> : include demagnetization or not, should be a boolean, i.e., true or false. By default,  demag=false.</li><li><code>H</code>: the external field, should be a tuple or function, i.e., <a href="../api_dev/#MicroMagnetic.TupleOrArrayOrFunction"><code>TupleOrArrayOrFunction</code></a>. </li><li><code>m0</code> : the initial magnetization, should be a tuple or function, i.e., <a href="../api_dev/#MicroMagnetic.TupleOrArrayOrFunction"><code>TupleOrArrayOrFunction</code></a>. </li><li><code>T</code> : the temperature, should be should be <a href="../api_dev/#MicroMagnetic.NumberOrArrayOrFunction"><code>NumberOrArrayOrFunction</code></a>.</li><li><code>shape</code> : the shape defines the geometry of the sample, where parameters are configured.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/sim.jl#L495-L525">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.relax" href="#MicroMagnetic.relax"><code>MicroMagnetic.relax</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">relax(sim::AbstractSim; max_steps=10000, stopping_dmdt=0.01, save_data_every=100, 
       save_m_every=-1, using_time_factor=true)</code></pre><p>Relaxes the system using either the <code>LLG</code> or <code>SD</code> driver. This function is compatible with both <a href="../equations/#Micromagnetic-model">Micromagnetic model</a> and <a href="../equations/#Atomistic-spin-model">Atomistic spin model</a>.</p><p><strong>Arguments:</strong></p><ul><li><code>max_steps::Int</code>: Maximum number of steps to run the simulation. Default is <code>10000</code>.</li><li><code>stopping_dmdt::Float64</code>: Primary stopping condition for both <code>LLG</code> and <code>SD</code> drivers. For standard micromagnetic simulations, typical values range from <code>0.01</code> to <code>1</code>. In <code>SD</code> driver mode, where time is not strictly defined, a factor of <code>γ</code> is applied to make it comparable to the <code>LLG</code> driver. For atomistic models using dimensionless units, set <code>using_time_factor</code> to <code>false</code> to disable this factor.</li><li><code>save_data_every::Int</code>: Interval for saving overall data such as energies and average magnetization. A negative value disables data saving (e.g., <code>save_data_every=-1</code> saves data only at the end of the relaxation).</li><li><code>save_m_every::Int</code>: Interval for saving magnetization data. A negative value disables magnetization saving.</li><li><code>using_time_factor::Bool</code>: Boolean flag to apply a time factor in <code>SD</code> mode for comparison with <code>LLG</code> mode. Default is <code>true</code>.</li></ul><p><strong>Examples:</strong></p><pre><code class="language-julia hljs">    relax(sim, max_steps=10000, stopping_dmdt=0.1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/sim.jl#L252-L271">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for `run_sim</p></div></div><h2 id="Interfaces-–-MicroMagnetic"><a class="docs-heading-anchor" href="#Interfaces-–-MicroMagnetic">Interfaces – MicroMagnetic</a><a id="Interfaces-–-MicroMagnetic-1"></a><a class="docs-heading-anchor-permalink" href="#Interfaces-–-MicroMagnetic" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.set_Ms-Tuple{MicroMagnetic.MicroSim, Union{Function, Number, Array}}" href="#MicroMagnetic.set_Ms-Tuple{MicroMagnetic.MicroSim, Union{Function, Number, Array}}"><code>MicroMagnetic.set_Ms</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_Ms(sim::MicroSim, Ms::NumberOrArrayOrFunction)</code></pre><p>Set the saturation magnetization Ms of the studied system. For example,</p><pre><code class="language-julia hljs">   set_Ms(sim, 8.6e5)</code></pre><p>or</p><pre><code class="language-julia hljs">function circular_Ms(i,j,k,dx,dy,dz)
    if (i-50.5)^2 + (j-50.5)^2 &lt;= 50^2
        return 8.6e5
    end
    return 0.0
end
set_Ms(sim, circular_Ms)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/sim.jl#L51-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.set_Ms-Tuple{MicroMagnetic.AbstractSim, MicroMagnetic.Shape, Number}" href="#MicroMagnetic.set_Ms-Tuple{MicroMagnetic.AbstractSim, MicroMagnetic.Shape, Number}"><code>MicroMagnetic.set_Ms</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_Ms(sim::AbstractSim, shape::Union{CSGNode,Shape}, Ms::Number)</code></pre><p>Set the saturation magnetization Ms within the Shape.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/sim.jl#L86-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.add_exch-Tuple{MicroMagnetic.MicroSim, Union{Function, Number, Tuple, Array}}" href="#MicroMagnetic.add_exch-Tuple{MicroMagnetic.MicroSim, Union{Function, Number, Tuple, Array}}"><code>MicroMagnetic.add_exch</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_exch(sim::MicroSim, A::NumberOrTupleOrArrayOrFunction; name=&quot;exch&quot;)</code></pre><p>Add exchange energy to the system. The exchange energy is definded as </p><p class="math-container">\[  E_\mathrm{ex} = \int_{V} A (\nabla \mathbf{m})^2 \mathrm{d}V\]</p><p><strong>Examples:</strong></p><pre><code class="language-julia hljs">    add_exch(sim, 1e-11)</code></pre><p>or </p><pre><code class="language-julia hljs">    add_exch(sim, (2e-12,5e-12,0))</code></pre><p>or</p><pre><code class="language-julia hljs">    function spatial_A(i,j,k,dx,dy,dz)
        if i&lt;10
            return 1e-11
        else
            return 2e-11
        end
    end
    add_exch(sim, spatial_A)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/micro/add_field.jl#L130-L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.add_dmi-Tuple{MicroMagnetic.MicroSim, Union{Function, Number, Tuple, Array}}" href="#MicroMagnetic.add_dmi-Tuple{MicroMagnetic.MicroSim, Union{Function, Number, Tuple, Array}}"><code>MicroMagnetic.add_dmi</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_dmi(sim::MicroSim, D::NumberOrTupleOrArrayOrFunction; name=&quot;dmi&quot;, type=&quot;bulk&quot;)</code></pre><p>Add DMI to the system. <code>type</code> could be &quot;bulk&quot;, &quot;interfacial&quot; or &quot;D2d&quot;. </p><p>Examples:</p><pre><code class="language-julia hljs">   add_dmi(sim, 1e-3, type=&quot;interfacial&quot;)</code></pre><p>or</p><pre><code class="language-julia hljs">   add_dmi(sim, 1e-3, type=&quot;D2d&quot;)</code></pre><pre><code class="language-julia hljs">   add_dmi(sim, (1e-3, 1e-3, 0), type=&quot;bulk&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/micro/add_field.jl#L195-L214">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.add_demag-Tuple{MicroMagnetic.MicroSim}" href="#MicroMagnetic.add_demag-Tuple{MicroMagnetic.MicroSim}"><code>MicroMagnetic.add_demag</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_demag(sim::MicroSim; name=&quot;demag&quot;, Nx=0, Ny=0, Nz=0, fft=true)</code></pre><p>Add Demag to the system. <code>Nx</code>, <code>Ny</code> and <code>Nz</code> can be used to describe the macro boundary conditions which means that the given mesh is repeated <code>2Nx+1</code>, <code>2Ny+1 and</code>2Nz+1<code>times in</code>x<code>,</code>y<code>and</code>z` direction, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/micro/add_field.jl#L301-L306">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.add_exch_int-Tuple{MicroMagnetic.MicroSim, Float64}" href="#MicroMagnetic.add_exch_int-Tuple{MicroMagnetic.MicroSim, Float64}"><code>MicroMagnetic.add_exch_int</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_exch_int(sim::AbstractSim, J::Float64; k1=1, k2=-1, name=&quot;rkky&quot;)</code></pre><p>Add an RKKY-type exchange for interlayers. The energy of RKKY-type exchange is defined as </p><p class="math-container">\[E_\mathrm{rkky} =  - \int_\Gamma J_\mathrm{rkky} \mathbf{m}_{i} \cdot \mathbf{m}_{j} dA\]</p><p>where <span>$\Gamma$</span> is the interface between two layers with magnetizations <span>$\mathbf{m}_{i}$</span> and <span>$\mathbf{m}_{j}$</span>, <span>$J_\mathrm{rkky}$</span> is the coupling constant which is related to the spacer layer thickness. </p><p>The effective field is given then as</p><p class="math-container">\[\mathbf{H}_i = \frac{1}{\mu_0 M_s}  \frac{J_\mathrm{rkky}}{\Delta_z} \mathbf{m}_{j} \]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/micro/add_field.jl#L565-L580">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.add_dmi_int-Tuple{MicroMagnetic.MicroSim, Tuple{Real, Real, Real}}" href="#MicroMagnetic.add_dmi_int-Tuple{MicroMagnetic.MicroSim, Tuple{Real, Real, Real}}"><code>MicroMagnetic.add_dmi_int</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_dmi_int(sim::MicroSimGPU, D::Tuple{Real, Real, Real}; k1=1, k2=-1, name=&quot;dmi_int&quot;)</code></pre><p>Add an interlayer DMI to the system. The energy of interlayer DMI is defined as </p><p class="math-container">\[E_\mathrm{dmi-int} =  \int_\Gamma \mathbf{D} \cdot \left(\mathbf{m}_{i} \times \mathbf{m}_{j}\right) dA\]</p><p>where <span>$\Gamma$</span> is the interface between two layers with magnetizations <span>$\mathbf{m}_{i}$</span> and <span>$\mathbf{m}_{j}$</span>.  <span>$\mathbf{D}$</span> is the effective DMI vector. </p><p>The effective field is given</p><p class="math-container">\[\mathbf{H}_i = \frac{1}{\mu_0 M_s \Delta_z}  \mathbf{D} \times \mathbf{m}_{j} \]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/micro/add_field.jl#L602-L617">source</a></section></article><h2 id="Interfaces-–-Atomistic"><a class="docs-heading-anchor" href="#Interfaces-–-Atomistic">Interfaces – Atomistic</a><a id="Interfaces-–-Atomistic-1"></a><a class="docs-heading-anchor-permalink" href="#Interfaces-–-Atomistic" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.set_mu_s-Tuple{MicroMagnetic.AtomisticSim, Union{Function, Number, Array}}" href="#MicroMagnetic.set_mu_s-Tuple{MicroMagnetic.AtomisticSim, Union{Function, Number, Array}}"><code>MicroMagnetic.set_mu_s</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_mu_s(sim::AtomisticSim, init::NumberOrArrayOrFunction)</code></pre><p>Set the magnetic moment <code>mu_s</code> for the given atomistic system <code>sim</code>.</p><p><strong>Usage Examples</strong></p><p>You can set a uniform magnetic moment for the entire system as follows:</p><pre><code class="language-julia hljs">set_mu_s(sim, 2 * mu_B)</code></pre><p>Alternatively, you can use a function to define spatially varying magnetic moments. For example, to set a circular region with a specific magnetic moment:</p><pre><code class="language-julia hljs">function circular_shape(i, j, k, dx, dy, dz)
    if (i - 50.5)^2 + (j - 50.5)^2 &lt;= 50^2
        return 2 * mu_B
    end
    return 0.0
end
set_mu_s(sim, circular_shape)</code></pre><p>The <code>circular_shape</code> function here assigns <code>2 * mu_B</code> to atoms within a circle of radius 50 (in lattice units), centered at <code>(50.5, 50.5)</code>,      while setting it to <code>0.0</code> outside this region.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/atomistic/sim.jl#L4-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.add_exch-Tuple{MicroMagnetic.AtomisticSim, Union{Number, Array}}" href="#MicroMagnetic.add_exch-Tuple{MicroMagnetic.AtomisticSim, Union{Number, Array}}"><code>MicroMagnetic.add_exch</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_exch(sim::AtomisticSim, J1::NumberOrArray; name=&quot;exch&quot;, J2=0, J3=0, J4=0)</code></pre><p>Add exchange interactions to the atomistic simulation <code>sim</code>.</p><p class="math-container">\[\mathcal{H}_\mathrm{ex} = -J \sum_{\langle i, j\rangle} \mathbf{m}_{i} \cdot \mathbf{m}_{j}\]</p><p><strong>Parameters</strong></p><ul><li><code>J1::NumberOrArray</code>: The first nearest-neighbor exchange coupling constant. Can be a single number (applied uniformly) or an array with a length equal to the number of first nearest neighbors.</li><li><code>J2, J3, J4</code> (optional): Exchange coupling constants for second, third, and fourth nearest neighbors, respectively. Each can be a single number or an array with lengths matching their corresponding neighbor counts.</li><li><code>name::String</code>: Optional identifier for the exchange interaction (default is <code>&quot;exch&quot;</code>).</li></ul><p><strong>Usage Examples</strong></p><p>To set a uniform exchange coupling for the first nearest neighbors:</p><pre><code class="language-julia hljs">add_exch(sim, 0.1*meV)</code></pre><p>To set different exchange couplings for multiple neighbor shells:</p><pre><code class="language-julia hljs">Js4 = [0.1*meV, 0.2*meV, 0.3*meV, 0.1*meV, 0.2*meV, 0.3*meV]
add_exch(sim, 0.1*meV, J2=0.2meV, J3=0.0, J4=Js4)</code></pre><p><strong>Notes</strong></p><p>If an array is provided for J1, J2, J3, or J4, its length must match the number of corresponding neighbors defined in the system&#39;s mesh. Otherwise, an error will be thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/atomistic/sim.jl#L74-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.add_exch-Tuple{MicroMagnetic.AtomisticSim, Function}" href="#MicroMagnetic.add_exch-Tuple{MicroMagnetic.AtomisticSim, Function}"><code>MicroMagnetic.add_exch</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_exch(sim::AtomisticSim, Jfun::Function; name=&quot;exch&quot;)</code></pre><p>Add spatial exchange interaction to the system by accepting a function that defines the exchange parameters at different spatial points.  The function should accept the indices <code>(i, j, k)</code> representing the position of the spin on the mesh and return an <strong>array</strong>.  The length of this array should be half the number of neighbors.</p><p>For example, for a <code>CubicMesh</code>, the function should return an array <code>[Jx, Jy, Jz]</code>, where:</p><ul><li><code>Jx</code> represents the exchange interaction between the site at <code>(i, j, k)</code> and the site at <code>(i+1, j, k)</code>,</li><li><code>Jy</code> represents the exchange interaction between the site at <code>(i, j, k)</code> and the site at <code>(i, j+1, k)</code>,</li><li><code>Jz</code> represents the exchange interaction between the site at <code>(i, j, k)</code> and the site at <code>(i, j, k+1)</code>.</li></ul><p>The array length corresponds to half the number of neighbors, because exchange interactions are considered only in the positive direction (i.e., the interactions with neighboring sites in increasing index directions).</p><p><strong>Examples:</strong></p><pre><code class="language-julia hljs">function spatial_J(i, j, k)
    Jx = i &lt; 10 ? 1meV : 2meV
    Jy = 1meV
    Jz = 1meV
    return [Jx, Jy, Jz]  # Returns an array
end

add_exch(sim, spatial_J)</code></pre><p>In this example:</p><ul><li>The exchange interaction in the x-direction (<code>Jx</code>) depends on the value of <code>i</code>. If <code>i</code> is less than 10, it is <code>1meV</code>, otherwise it is <code>2meV</code>.</li><li>The interactions in the y- and z-directions (<code>Jy</code> and <code>Jz</code>) are fixed at <code>1meV</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/atomistic/sim.jl#L213-L243">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.add_exch_bq-Tuple{MicroMagnetic.AtomisticSim, Union{Number, Array}}" href="#MicroMagnetic.add_exch_bq-Tuple{MicroMagnetic.AtomisticSim, Union{Number, Array}}"><code>MicroMagnetic.add_exch_bq</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_exch_bq(sim::AtomisticSim, K::NumberOrArray; name=&quot;exch_bq&quot;)</code></pre><p>Add biquadratic exchange interaction to the atomistic simulation <code>sim</code>. The biquadratic exchange interaction is defined as</p><p class="math-container">\[\mathcal{H}_\mathrm{ex} = - \sum_{\langle i, j\rangle} K_{ij} (\mathbf{m}_{i} \cdot \mathbf{m}_{j})^2\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/atomistic/sim.jl#L173-L182">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.add_dmi-Tuple{MicroMagnetic.AtomisticSim, Real}" href="#MicroMagnetic.add_dmi-Tuple{MicroMagnetic.AtomisticSim, Real}"><code>MicroMagnetic.add_dmi</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_dmi(sim::AtomisticSim, D::Real; name=&quot;dmi&quot;, type=&quot;bulk&quot;)</code></pre><p>Add DMI to the system. <code>type</code> could be &quot;bulk&quot; or &quot;interfacial&quot;. The DMI is defined as</p><p class="math-container">\[\mathcal{H}_\mathrm{dmi} = \sum_{\langle i, j\rangle}  \mathbf{D}_{i j} \cdot\left(\mathbf{m}_{i} \times \mathbf{m}_{j}\right)\]</p><p>where <span>$\mathbf{D}_{i j}$</span> is the DM vector. For the bulk dmi <span>$\mathbf{D}_{i j} = D \hat{r}_{ij}$</span> and for interfacial dmi <span>$\mathbf{D}_{i j} = D \hat{r}_{ij} \times \hat{z}$</span>.</p><p>Examples:</p><pre><code class="language-julia hljs">   J = 0.1 * meV
   add_dmi(sim, 0.01*J, type=&quot;bulk&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/atomistic/sim.jl#L295-L310">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.add_dmi-Tuple{MicroMagnetic.AtomisticSim, Matrix{&lt;:Real}}" href="#MicroMagnetic.add_dmi-Tuple{MicroMagnetic.AtomisticSim, Matrix{&lt;:Real}}"><code>MicroMagnetic.add_dmi</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_dmi(sim::AtomisticSim, Dij::Array{&lt;:Real, 2}; name=&quot;dmi&quot;)</code></pre><p>Add Dzyaloshinskii-Moriya Interaction (DMI) to the system, defined as:</p><p class="math-container">\[\mathcal{H}_\mathrm{dmi} = \sum_{\langle i, j\rangle} \mathbf{D}_{ij} \cdot \left(\mathbf{m}_{i} \times \mathbf{m}_{j}\right)\]</p><p>where <span>$\mathbf{D}_{ij}$</span> is the DMI vector. The <code>Dij</code> array should have size <code>(3, mesh.n_ngbs)</code> and represents the DMI vectors between each pair of neighboring sites. For example, for a <code>CubicMesh</code>, the <code>Dij</code> array should be an array of DMI vectors <code>[D1, D2, D3, D4, D5, D6]</code>, where:</p><ul><li><code>D1</code> is the DMI vector between the site at <code>(i, j, k)</code> and the site at <code>(i-1, j, k)</code>,</li><li><code>D2</code> is the DMI vector between the site at <code>(i, j, k)</code> and the site at <code>(i+1, j, k)</code>,</li><li><code>D3</code> is the DMI vector between the site at <code>(i, j, k)</code> and the site at <code>(i, j-1, k)</code>,</li><li><code>D4</code> is the DMI vector between the site at <code>(i, j, k)</code> and the site at <code>(i, j+1, k)</code>,</li><li><code>D5</code> is the DMI vector between the site at <code>(i, j, k)</code> and the site at <code>(i, j, k-1)</code>,</li><li><code>D6</code> is the DMI vector between the site at <code>(i, j, k)</code> and the site at <code>(i, j, k+1)</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Define bulk DMI for a CubicMesh
D = 0.1 * meV
Dij = hcat([-D, 0, 0],  # DMI vector for (i-1, j, k)
           [D, 0, 0],   # DMI vector for (i+1, j, k)
           [0, -D, 0],  # DMI vector for (i, j-1, k)
           [0, D, 0],   # DMI vector for (i, j+1, k)
           [0, 0, -D],  # DMI vector for (i, j, k-1)
           [0, 0, D])   # DMI vector for (i, j, k+1)

add_dmi(sim, Dij)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/atomistic/sim.jl#L405-L434">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.add_dmi-Tuple{MicroMagnetic.AtomisticSim, Function}" href="#MicroMagnetic.add_dmi-Tuple{MicroMagnetic.AtomisticSim, Function}"><code>MicroMagnetic.add_dmi</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_dmi(sim::AtomisticSim, Dfun::Function; name=&quot;dmi&quot;)</code></pre><p>Add spatial DMI to the system. The DMI is defined as</p><p class="math-container">\[\mathcal{H}_\mathrm{dmi} = \sum_{\langle i, j\rangle}  \mathbf{D}_{i j} \cdot\left(\mathbf{m}_{i} \times \mathbf{m}_{j}\right)\]</p><p>where <span>$\mathbf{D}_{i j}$</span> is the DM vector.  The function should accept the indices <code>(i, j, k)</code> representing the position of the spin  on the mesh and return an <strong>array</strong>. The length of this array should be half the number of neighbors.</p><p>For example, for a <code>CubicMesh</code>, the function should return an array <code>[(D1, D2, D3), (D4, D5, D6), (D4, D5, D6)]</code>, where:</p><ul><li><code>(D1, D2, D3)</code> represents the DM vector between the site at <code>(i, j, k)</code> and the site at <code>(i+1, j, k)</code>,</li><li><code>(D4, D5, D6)</code> represents the DM vector between the site at <code>(i, j, k)</code> and the site at <code>(i, j+1, k)</code>,</li><li><code>(D7, D8, D9)</code> represents the DM vector between the site at <code>(i, j, k)</code> and the site at <code>(i, j, k+1)</code>.</li></ul><p>The array length corresponds to half the number of neighbors, because exchange interactions are considered only in the positive direction (i.e., the interactions with neighboring sites in increasing index directions).</p><p><strong>Examples:</strong></p><pre><code class="language-julia hljs">function spatial_bulk_DMI(i, j, k)
    Dx = i &lt; 10 ? 0.1meV : 0.2meV
    Dy = 0.1meV
    Dz = 0.3meV
    return [(Dx, 0, 0), (0, Dy, 0), (0, 0, Dz)]  # Returns an array
end

add_dmi(sim, spatial_bulk_DMI)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/atomistic/sim.jl#L453-L482">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.add_demag-Tuple{MicroMagnetic.AtomisticSim}" href="#MicroMagnetic.add_demag-Tuple{MicroMagnetic.AtomisticSim}"><code>MicroMagnetic.add_demag</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_demag(sim::AtomisticSim; name=&quot;demag&quot;, Nx=0, Ny=0, Nz=0 )</code></pre><p>add dipolar interaction into the system.</p><p class="math-container">\[\mathcal{H}_{\mathrm{d}}=-\frac{\mu_0 \mu_s^2}{4 \pi} \sum_{i&lt;j} \frac{3\left(\mathbf{m}_i \cdot \hat{\mathbf{r}}_{i j}\right)\left(\mathbf{m}_j \cdot \hat{\mathbf{r}}_{i j}\right)-\mathbf{m}_i \cdot \mathbf{m}_j}{r_{i j}^3}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/atomistic/sim.jl#L659-L667">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.add_exch_kagome-Tuple{MicroMagnetic.AtomisticSim, Number, Number}" href="#MicroMagnetic.add_exch_kagome-Tuple{MicroMagnetic.AtomisticSim, Number, Number}"><code>MicroMagnetic.add_exch_kagome</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_exch_kagome(sim::AtomisticSim, Jxy::Number, Jz::Number; name=&quot;exch&quot;)</code></pre><p>Add exchange energy to the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/atomistic/sim.jl#L537-L541">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.add_anis_kagome-Tuple{MicroMagnetic.AtomisticSim, Float64}" href="#MicroMagnetic.add_anis_kagome-Tuple{MicroMagnetic.AtomisticSim, Float64}"><code>MicroMagnetic.add_anis_kagome</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_anis_kagome(sim::AtomisticSim, Ku::Float64; ax1=(-0.5,-sqrt(3)/2,0), ax2=(1,0,0), ax3=(-0.5,sqrt(3)/2,0), name=&quot;anis&quot;)</code></pre><p>Add Anisotropy for kagome system, where the energy density is given by</p><p class="math-container">\[E_\mathrm{anis} = - K_{u} (\vec{m} \cdot \hat{u})^2\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/atomistic/sim.jl#L555-L563">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.add_anis_tube-Tuple{MicroMagnetic.AtomisticSim, Float64}" href="#MicroMagnetic.add_anis_tube-Tuple{MicroMagnetic.AtomisticSim, Float64}"><code>MicroMagnetic.add_anis_tube</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_anis_tube(sim::AtomisticSim, Ku::Float64; name=&quot;anis&quot;)</code></pre><p>add anisotropy to the system when the tube mesh is used. The anisotropy axis <span>$u$</span>  is along with the radial direction.</p><p class="math-container">\[E_\mathrm{anis} = - K_{u} (\vec{m} \cdot \hat{u})^2\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/atomistic/sim.jl#L582-L591">source</a></section></article><h2 id="DataSaving"><a class="docs-heading-anchor" href="#DataSaving">DataSaving</a><a id="DataSaving-1"></a><a class="docs-heading-anchor-permalink" href="#DataSaving" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.save_vtk" href="#MicroMagnetic.save_vtk"><code>MicroMagnetic.save_vtk</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">save_vtk(mesh::Mesh, shape::Union{CSGNode,Shape}, fname::String)</code></pre><p>Save the shape to vtk. </p><pre><code class="language-julia hljs">    mesh = FDMesh(dx=2e-9, dy=2e-9, dz=2e-9, nx=100, ny=100, nz=50)
    t1 = Torus(R = 60e-9, r=20e-9)
    save_vtk(mesh, t1, &quot;torus&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/csg.jl#L198-L208">source</a></section><section><div><pre><code class="language-julia hljs">save_vtk(sim::AbstractSim, fname::String; fields::Array{String, 1} = String[])</code></pre><p>Save magnetization or other fields to vtk.</p><pre><code class="language-julia hljs">    save_vtk(sim, &quot;m&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/vtk.jl#L27-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.save_ovf" href="#MicroMagnetic.save_ovf"><code>MicroMagnetic.save_ovf</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">save_ovf(sim::AbstractSim, fname::String; type::DataType = Float64)</code></pre><p>Save spins by ovf, which can be viewed by Muview. </p><p>Parameters:</p><pre><code class="nohighlight hljs">Sim : Sim struct whose spin to be saved.

fname : Save file name.</code></pre><p>Optional:</p><pre><code class="nohighlight hljs">type : Data type of ovf2 file. Can be chosen from Float32, Float64 or String.</code></pre><p>For example:</p><pre><code class="nohighlight hljs">```julia
    save_ovf(sim, &quot;ovf_example&quot;)
```</code></pre><p>Or to specify a certain data type:</p><pre><code class="nohighlight hljs">```julia
    save_ovf(sim, &quot;ovf_example&quot;, type = String)
```</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/ovf2.jl#L17-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.read_ovf" href="#MicroMagnetic.read_ovf"><code>MicroMagnetic.read_ovf</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">read_ovf(sim, fname)

Initialize sim with an ovf file named of &quot;fname.ovf&quot;.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/ovf2.jl#L201-L205">source</a></section><section><div><pre><code class="language-julia hljs">read_ovf(fname)

Load ovf file as OVF2 Type, where spin is stored in OVF2.data</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/ovf2.jl#L257-L261">source</a></section></article><h2 id="Tools"><a class="docs-heading-anchor" href="#Tools">Tools</a><a id="Tools-1"></a><a class="docs-heading-anchor-permalink" href="#Tools" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.ovf2vtk" href="#MicroMagnetic.ovf2vtk"><code>MicroMagnetic.ovf2vtk</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ovf2vtk(ovf_name, vtk_name=nothing; point_data=false, box=noting)</code></pre><p>Convert ovf file to vtk format. The data will be saved to points if point_data == true otherwise the data will be saved to cells.</p><p>If box is not nothing, it should be a tuple. For instance, box = (nx1, nx2, ny1, ny2, nz1, nz2). In this case, the generated vtk only contains the spins inside the box (including the boundary).</p><pre><code class="language-julia hljs">    ovf2vtk(&quot;my.ovf&quot;, &quot;test.vts&quot;)
    ovf2vtk(&quot;my.ovf&quot;, point_data=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/vtk.jl#L134-L147">source</a></section></article><h2 id="Others"><a class="docs-heading-anchor" href="#Others">Others</a><a id="Others-1"></a><a class="docs-heading-anchor-permalink" href="#Others" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.MicroSim" href="#MicroMagnetic.MicroSim"><code>MicroMagnetic.MicroSim</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MicroSim{T&lt;:AbstractFloat} &lt;: AbstractSim</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/head.jl#L107-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.AtomisticSim" href="#MicroMagnetic.AtomisticSim"><code>MicroMagnetic.AtomisticSim</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AtomisticSim{T&lt;:AbstractFloat} &lt;: AbstractSim</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticSimulation/MicroMagnetic.jl/blob/28e3c99abfad168e7e645121117823b97e91acd6/src/atomistic/head.jl#L2-L4">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../equations/">« Equations</a><a class="docs-footer-nextpage" href="../api_dev/">API for developers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Sunday 16 February 2025 04:33">Sunday 16 February 2025</span>. Using Julia version 1.10.8.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
